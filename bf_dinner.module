<?php

/*
 * Dinner statuses
 */
// default
define('DINNER_STATE_SCHEDULED', 1);
// in case of house being booked for other purpose
define('DINNER_STATE_NOT_SCHEDULED', 0);
// not used yet
define('DINNER_STATE_OPEN', 2);
//
define('DINNER_STATE_CLOSED', 3);
// not used yet
define('DINNER_STATE_PASSED', 4);
// in case of illness
define('DINNER_STATE_CANCELLED_LEGAL', 5);
//
define('DINNER_STATE_CANCELLED_ILLEGAL', 6);

/*
 * Dinner load values. The dinner load is the amount of points a user is credited when being assigned a date.
 */
// two cooks, two dinners
define('DINNER_LOAD_HALF', 1);
// one cook, one dinner
define('DINNER_LOAD_SINGLE', 2);
// two cooks, one dinner
define('DINNER_LOAD_DOUBLE', 4);

/**
 *
 */
// unknown
define('DINNER_USER_DATE_STATUS_UNKNOWN', -1);
// the user cannot be assigned to this date
define('DINNER_USER_DATE_STATUS_NOT_POSSIBLE', 0);
// the user can be assigned to this date
define('DINNER_USER_DATE_STATUS_POSSIBLE', 1);
// the user is assigned to this date
define('DINNER_USER_DATE_STATUS_ASSIGNED', 2);

/**
 * fields :
 */
// fields on node entity :
define('DINNER_FIELD_USERS', 'field_users');
// Which series does this belong to. Int - increment by one on each series.
define('DINNER_FIELD_DATE_SERIES', 'field_dinner_dinner_series');
// Which series does this belong to. Int - increment by one on each series.
define('DINNER_FIELD_DATE_STATE', 'field_dinner_dinner_state');
//
define('DINNER_FIELD_DATE_DATE', 'field_date');

define('DINNER_FIELD_DATE_DATEINTERVAL', 'field_dateinterval');

// På dansk : "Antal kokke pr. day" - in points
define('DINNER_FIELD_DATE_LOAD', 'field_dinner_dinner_load');
// på dansk : "Mad med børn"
define('DINNER_FIELD_DATE_KIDS', 'field_withchildren');

// fields on user entity
//
define('DINNER_FIELD_USER_NAME', 'field_alias');
//
define('DINNER_FIELD_USER_HOUSE', 'field_house');
// "Antal kokketjanser i den kommende runde" - in points
define('DINNER_FIELD_USER_LOAD_TOTAL', 'field_dinner_user_load_total');
// "Lave mad alene eller sammen med en anden" - in points
define('DINNER_FIELD_USER_LOAD_PRDAY', 'field_dinner_user_load_prday');
// på dansk : "Mad med børn"
define('DINNER_FIELD_USER_KIDS', 'field_dinner_user_kids');
// date when form was opened last time - can be cleared after XX sec.
define('DINNER_FIELD_USER_LAST_FORM_OPEN', 'field_dinner_user_form_open');

require_once (DRUPAL_ROOT . '/' . drupal_get_path('module', 'bf_dinner') . '/src/Entity/Date.php');
require_once (DRUPAL_ROOT . '/' . drupal_get_path('module', 'bf_dinner') . '/src/Entity/Series.php');
require_once (DRUPAL_ROOT . '/' . drupal_get_path('module', 'bf_dinner') . '/src/Entity/User.php');

/**
 * Implements hook_permission.
 *
 * @return array
 */
function bf_dinner_permission () {
	return array(
		'bf dinner admin' => array(
			'title' => t('Administer dinner assignment system'),
			'description' => t('Perform administration tasks for dinner assignment system.'),
		),
		'bf dinner access to closed' => array(
			'title' => t('Access to closed dinner forms'),
			'description' => t('Access to dinner forms, even if closed.'),
		)
	);
}


/**
 * Implements hook_menu.
 *
 * @return array
 */
function bf_dinner_menu() {
	return array(

		/**
		 * Admin pages and forms
		 */
		'admin/dinner' => array(
			'title' => 'Fællesspisning',
			'page callback' => 'bf_dinner_admin_front',
			'file' => 'bf_dinner.admin.inc',
			'page arguments' => array('bf_dinner_admin_front'),
			'access callback' => 'user_access',
			'access arguments' => array('bf dinner admin'),
			'type' => MENU_NORMAL_ITEM,

		),

		'admin/dinner/create' => array(
			'title' => 'Opret kommende',
			'page callback' => 'drupal_get_form',
			'file' => 'bf_dinner.admin.inc',
			'page arguments' => array('bf_dinner_admin_create'),
			'access callback' => 'user_access',
			'access arguments' => array('bf dinner admin'),
			'type' => MENU_NORMAL_ITEM,
			'weight' => 10,

		),

		'admin/dinner/users' => array(
			'title' => 'Kokke',
            'page callback' => 'bf_dinner_admin_users',
            'file' => 'bf_dinner.admin.inc',
			'access callback' => 'user_access',
			'access arguments' => array('bf dinner admin'),
			'type' => MENU_NORMAL_ITEM,
			'weight' => 10,
		),

        'user/%/dinner' => array(
            'title' => 'Kok',
            'page callback' => 'bf_dinner_admin_user',
            'page arguments' => array(1),
            'file' => 'bf_dinner.admin.inc',
            'access callback' => 'user_access',
            'access arguments' => array('bf dinner admin'),
            'type' => MENU_NORMAL_ITEM,
            'weight' => 10,
        ),

        'admin/dinner/dates' => array(
            'title' => 'Datoer',
            'page callback' => 'bf_dinner_admin_dates',
            'file' => 'bf_dinner.admin.inc',
            'access callback' => 'user_access',
            'access arguments' => array('bf dinner admin'),
            'type' => MENU_NORMAL_ITEM,
            'weight' => 10,
        ),

        'admin/dinner/assign' => array(
			'title' => 'Fordel',
			'page callback' => 'drupal_get_form',
			'file' => 'bf_dinner.admin.inc',
			'page arguments' => array('bf_dinner_admin_assign'),
			'access callback' => 'user_access',
			'access arguments' => array('bf dinner admin'),
			'type' => MENU_NORMAL_ITEM,
			'weight' => 20,

		),

		'admin/dinner/publish' => array(
			'title' => 'Offentliggør',
			'page callback' => 'drupal_get_form',
			'file' => 'bf_dinner.admin.inc',
			'page arguments' => array('bf_dinner_admin_publish'),
			'access callback' => 'user_access',
			'access arguments' => array('bf dinner admin'),
			'type' => MENU_NORMAL_ITEM,
			'weight' => 30,

		),
		'admin/dinner/settings' => array(
			'title' => 'Indstillinger',
			'page callback' => 'drupal_get_form',
			'file' => 'bf_dinner.admin.inc',
			'page arguments' => array('bf_dinner_admin_settings_form'),
			'access callback' => 'user_access',
			'access arguments' => array('bf dinner admin'),
			'type' => MENU_NORMAL_ITEM,
			'weight' => 100,

		),

		'admin/dinner_assignment_ajax' => array(
			'title' => 'Assignment ajax',
			'page callback' => 'bf_dinner_assignment_ajax',
			'file' => 'bf_dinner.admin.inc',
			'page_arguments' => array(1, 2, 3),
			'access callback' => 'user_access',
			'access arguments' => array('bf dinner admin'),
			'type' => MENU_CALLBACK,
		),

		/**
		 * User form.
		 */
		'dinner' => array(
			'title' => 'Kan-liste',
			'page callback' => 'drupal_get_form',
			'file' => 'bf_dinner.pages.inc',
			'page arguments' => array('bf_dinner_user_status_form'),
			'access callback' => 'user_is_logged_in',
			'type' => MENU_NORMAL_ITEM,
			'weight' => 100,

		),
		'dinner_conflict_ajax' => array(
			'title' => 'Conflict ajax',
			'page callback' => 'bf_dinner_conflict_ajax',
			'file' => 'bf_dinner.pages.inc',
			'page_arguments' => array(),
			'access callback' => 'user_is_logged_in',
			'type' => MENU_CALLBACK,
		),

	);
}

function bf_dinner_page_build () {
	global $user;
	if (!user_is_anonymous() && empty($GLOBALS['bf_dinner_is_dinner_page'])) {
		bf_dinner_utility::setUserFormLastOpenDate($user->uid, FALSE);
	}
}

/**
 * 	 * @TODO : something not working here ....

 */
function bf_dinner_cron () {
    return;

	$rows = db_select('bf_dinner_user_date_status', 'mm')
		->fields('mm')
		->condition('series', 0, '=')
		->groupBy('mm.date')
		->execute()->fetchAll();

	foreach ($rows as $row) {

		$series = bf_dinner_utility::getDateSeries($row->date);
/*		db_update('bf_dinner_user_date_status')
			->fields(array(
				'series' => 1,
			))
			->condition('date', $row->date, '=')
			->execute();
*/
}
	die(__FUNCTION__);
}

/**
 * Class bf_dinner_utility
 * Utility class with various static methods.
 */
class bf_dinner_utility {

	/**
	 * That's user's name, not username
	 */
	public static function getUserName ($uid) {
		if (is_object($uid)) {
			$uid = $uid->uid;
		}
		$u = user_load($uid);

		if ($temp = field_get_items('user', $u, DINNER_FIELD_USER_NAME)) {
			return $temp['0']['value'];
		}

		// return username
		return $u->name;
	}

	/**
	 * @param $date
	 * @return bool|mixed
	 */
	public static function getDateNode ($date) {
	    if ($date instanceof \DateTime) {
	        $date = $date->format('Y-m-d');
        }
		$nodes = self::getEntityFieldQuery()
			->fieldCondition(DINNER_FIELD_DATE_DATE, 'value', $date)
			->execute();

        if (! sizeof($nodes['node'])) {
            return FALSE;
        }

		list(, $node) = each($nodes['node']);
		$node = node_load($node->nid);
		return $node;
	}

	/**
	 * @TODO : something not working here ....
	 *
	 * @param $date
	 * @return int
	 */
	public static function getDateSeries ($date) {
		if ($node = self::getDateNode($date)) {
			if ($temp = field_get_items('node', $node, DINNER_FIELD_DATE_SERIES)) {
				return $temp['0']['value'];
			}
		}
		return 0;
	}

	/**
	 * @param $nid stdClass|int
	 * @param int $default
	 * @return int
	 */
	public static function getDateState ($nid, $default = DINNER_STATE_SCHEDULED) {
		if (is_object($nid)) {
			$nid = $nid->nid;
		}
		$nid = node_load($nid);

		if ($temp = field_get_items('node', $nid, DINNER_FIELD_DATE_STATE)) {
			return $temp['0']['value'];
		}
		return $default;
	}

	/**
	 * @param $nid stdClass|int
	 * @param int $default
	 * @return int
	 */
	public static function getDateLoad ($nid, $default = DINNER_LOAD_SINGLE) {
		if (is_object($nid)) {
			$nid = $nid->nid;
		}
		$nid = node_load($nid);

		if (self::getDateState($nid, 0) == 0) {
			return 0;
		}

		if ($temp = field_get_items('node', $nid, DINNER_FIELD_DATE_LOAD)) {
			return $temp['0']['value'];
		}
		return $default;
	}

	/**
	 * @param $user stdClass|int User object or UID
	 */
	public static function getUserLoadPrDay($uid, $default = DINNER_LOAD_SINGLE) {

		if (is_object($uid)) {
			$uid = $uid->uid;
		}
		$u = user_load($uid);

		if ($temp = field_get_items('user', $u, DINNER_FIELD_USER_LOAD_PRDAY)) {
			return $temp['0']['value'];
		}

		return $default;
	}

	/**
	 * @param $uid
	 * @param $load
	 */
	public static function setUserLoadPrDay ($uid, $load) {
		self::setUserFieldValue($uid, DINNER_FIELD_USER_LOAD_PRDAY, $load);
	}

	/**
	 * Returns first value of field on node. If field is empty, returns false.
	 *
	 * @param $uid
	 * @param $field
	 */
	public static function getDateFieldValue ($nid, $field, $default = FALSE) {
		if (is_object($nid)) {
			$nid = $nid->nid;
		}
		$n = node_load($nid);

		if ($temp = field_get_items('node', $n, $field)) {
			return $temp['0']['value'];
		}

		return $default;
	}

	/**
	 * Returns first value of field on user account. If field is empty, returns false.
	 *
	 * @param $uid
	 * @param $field
	 */
	public static function getUserFieldValue ($uid, $field, $default = FALSE) {
		if (is_object($uid)) {
			$uid = $uid->uid;
		}
		$u = user_load($uid);

		if ($temp = field_get_items('user', $u, $field)) {
			return $temp['0']['value'];
		}

		return $default;

	}

	/**
	 *
	 * @param $uid
	 * @param string|FALSE $date
	 */
	public static function setUserFormLastOpenDate ($uid, $date = 'NOW') {
		if (empty($uid)) {
			return;
		}
		if (FALSE === $date) {
			$date = new \DateTime();
			$date->setTimestamp(0);
		}
		if ($date == 'NOW') {
			$date = new \DateTime();
			$date->setTimestamp(time());
		}
		if (is_string($date)) {
			$date = new \DateTime($date);
		}
		self::setUserFieldValue($uid, DINNER_FIELD_USER_LAST_FORM_OPEN, $date->getTimestamp());
	}

	/**
	 *
	 * @param $uid
	 * @param string $date
	 */
	public static function getUserFormLastOpenDate ($uid) {
		if ($s = self::getUserFieldValue($uid, DINNER_FIELD_USER_LAST_FORM_OPEN)) {
				$date = new \DateTime($s);
			$date->setTimestamp($date->getTimestamp() + 7200);
			return $date;
		}
		return FALSE;
	}

	/**
	 *
	 */
	public static function setUserFieldValue ($uid, $field, $value) {
		if (is_object($uid)) {
			$uid = $uid->uid;
		}
		if (empty($uid)) {
			return FALSE;
		}
		$u = user_load($uid);
		$user_wrapper = entity_metadata_wrapper('user', $u);
		$user_wrapper->$field->set($value);
		$user_wrapper->save();

		return TRUE;
	}

	/**
	 * Retrieve a single status for one user on one date.
	 *
	 * @param $uid
	 * @param $date string|\DateTime
	 * @return bool|int
	 */
	public static function getUserDateStatus($uid, $date, $default = FALSE) {
		if ($date instanceof \DateTime) {
			$date = $date->format('Y-m-d');
		}
		// fetch status from database
		$status = db_select('bf_dinner_user_date_status', 'mm')
			->fields('mm')
			->condition('uid', $uid, '=')
			->condition('date', $date, '=')
			->execute()->fetchAll();

        // if there is a row for this combination and the row has a non-null status, return it
		if (sizeof($status) && ! is_null($status[0]->status)) {
			return $status[0]->status;
		}

		return $default;
	}

	/**
	 * Get multiple user statuses for one single date.
	 *
	 * @param $uid
	 * @param $date string|\DateTime
	 * @return array Array of user statuses keyed by uid.
	 */
	public static function getUserDateStatuses(array $uids, $date, $default = FALSE) {
		// set default
		$o = array();
		foreach ($uids as $uid) {
			$o[$uid] = $default;
		}
		// sanitize date
		if ($date instanceof \DateTime) {
			$date = $date->format('Y-m-d');
		}
		// fetch status from database
		$status = db_select('bf_dinner_user_date_status', 'mm')
			->fields('mm')
			->condition('uid', $uids, 'in')
			->condition('date', $date, '=')
			->execute()->fetchAll();

		if (sizeof($status)) {
			foreach ($status as $f) {
				$o[$f->uid] = $f->status;
			}
		}

		return $o;
	}

	/**
	 * Write a single user date status to database.
	 *
	 * @param $uid int
	 * @param $date string
	 * @param $status int
	 */
	public static function setUserDateStatus($uid, $date, $status) {
		if ($date instanceof \DateTime) {
			$date = $date->format('Y-m-d');
		}

		// write status to database
		db_merge('bf_dinner_user_date_status')
			->key(array(
				'uid' => $uid,
				'date' => $date
			))
			->fields(array(
				'uid' => $uid,
				'date' => $date,
				'status' => $status,
				'changed' => time(),
			))
			->execute();
	}

	/**
	 * @param $uid int User id
	 * @param $date string Date
	 * @param $assigned int As
	 * @return bool True if success (pt. always true)
	 */
	public static function setDateUserAssignment ($uid, $date, $assigned) {
		if ($date instanceof \DateTime) {
			$date = $date->format('Y-m-d');
		}

		// Fetch status first. This is to avoid changing it, if DB default value differs from UI default value.
		$status = self::getUserDateStatus($uid, $date, DINNER_USER_DATE_STATUS_UNKNOWN);

		db_merge('bf_dinner_user_date_status')
			->key(array(
				'uid' => $uid,
				'date' => $date
			))
			->fields(array(
				'uid' => $uid,
				'date' => $date,
                'status' => $status,
				'assigned' => $assigned ? 1 : 0,
			))
			->execute();

		return TRUE;
	}

	/**
	 *
	 *
	 * @param $uid int
	 * @param $date string
	 * @param $status int
	 * @return bool Were all users assigned successfully to this date.
	 */
	public static function setDateAssignedUsers($uids, $date) {
		if ($date instanceof \DateTime) {
			$date = $date->format('Y-m-d');
		}

		// unassign everyone on this date
		db_update('bf_dinner_user_date_status')
			->condition('date', $date)
			->fields(array(
				'assigned' => 0,
			))
			->execute();

		// assign those in uids
		foreach ($uids as $uid) {
			if ($uid) {
				db_merge('bf_dinner_user_date_status')
					->key(array(
						'uid' => $uid,
						'date' => $date
					))
					->fields(array(
						'uid' => $uid,
						'date' => $date,
						'assigned' => 1,
					))
					->execute();
			}
		}

		return TRUE;
	}

	/**
	 *
	 *
	 * @param $uid int
	 * @param $date string
	 * @param $status int
	 */
	public static function getAssignedUsers($date) {
		if ($date instanceof \DateTime) {
			$date = $date->format('Y-m-d');
		}

		$res = db_select('bf_dinner_user_date_status')
			->fields('bf_dinner_user_date_status')
			->condition('date', $date)
			->condition('assigned', 1)
			->execute();

		$out = array();
		foreach ($res as $us) {
			$out[] = intval($us->uid);
		}

		return $out;
	}

	/**
	 * Get the date of the last published dinner node.
	 *
	 * @return \DateTime
	 */
	public static function getLastPublishedDate() {
		$node = self::getLastPublishedNode();
		list($date) = field_get_items('node', $node, 'field_date');
		return new DateTime($date['value']);
	}

	/**
	 * Get the published dinner node that has the last date.
	 *
	 * @return bool|mixed
	 */
	public static function getLastPublishedNode() {
		$nodes = self::getEntityFieldQuery()
			->propertyCondition('status', 1)
			->fieldOrderBy('field_date', 'value', 'DESC')
			->range(0, 1)
			->execute();
		list(, $node) = each($nodes['node']);
		$node = node_load($node->nid);
		return $node;

	}

	/**
	 * Returns all unpublished future nodes.
	 *
	 * @return mixed
	 */
	public static function getAllUnpublishedNodes() {
		$nodes = self::getEntityFieldQuery()
			->propertyCondition('status', 0)
//			->fieldCondition('field_date', 'value', date('Y-m-d'), '>')
			->fieldOrderBy('field_date', 'value', 'ASC')
            ->entityOrderBy('entity_id', 'ASC')
			->execute();

		return self::convertArrayOfNodeObjectsToArrayOfDateObjects($nodes['node']);
	}

    public static function getAllUnpublishedNodesWUsers($withoutUsers = FALSE) {

        $nodes = self::getEntityFieldQuery()
            ->propertyCondition('status', 0)
            ->execute();

        $result = [];
        foreach ($nodes['node'] as $node) {
            $node = node_load($node->nid);
            if ($withoutUsers XOR field_get_items('node', $node, DINNER_FIELD_USERS)) {
                $result[] = $node;
            }
        }
        return $result;

	}

    /**
     * Writes the result to database, for administrator to review.
     */
    public static function writeTemporaryAssignmentsToPermanent () {
        $stat = [];
        $nodes = bf_dinner_utility::getAllNodesInCurrentSeries();

        /** @var \Drupal\bf_dinner\Entity\Date $date */
        foreach ($nodes as $date) {
            $old = $date->{DINNER_FIELD_USERS};
            // @TODO : what to do with old ?

            if (sizeof($date->getTempAssignmentUids())) {

	            $temp = [];
        	    foreach ($date->getTempAssignmentUids() as $uid) {
                	$temp[] =[
      	              'target_id' => $uid,
        	        ];
            	}	
            	$date->{DINNER_FIELD_USERS}{LANGUAGE_NONE} = $temp;
            	$date->status = 1;

	            node_save($date);
        	    $stat['saved'] ++;
		}
        }
        drupal_set_message(sprintf("Stored %d nodes.", $stat['saved']));
    }

    /**
     * @return array
     */
    public static function getNodesForPublishing() {
        $out = [];
        /** @var \Drupal\bf_dinner\Entity\Date $date */
        foreach (self::getAllUnpublishedNodes() as $date) {
            if ($date->canBePublished()) {
                $out[] = $date;
            }
        }

        return $out;
	}

	/**
	 * Published or unpublished doesn't matter
	 */
	public static function getAllNodesInCurrentSeries() {
	    return self::getAllNodesInSeries(self::getCurrentSeriesId());

	}

    /**
     * @param $date1
     * @param $date2
     * @return \Drupal\bf_dinner\Entity\Date[]
     */
    public static function getAllNodesBetweenDates($date1, $date2)
    {
        $nodes = self::getEntityFieldQuery()
            ->fieldCondition('field_date', 'value', $date1->format('Y-m-d'), '>=')
            ->fieldCondition('field_date', 'value', $date2->format('Y-m-d'), '<=')
            ->fieldOrderBy('field_date', 'value', 'ASC')
            ->execute();

        return self::convertArrayOfNodeObjectsToArrayOfDateObjects($nodes['node']);

    }

    /**
     * @return \Drupal\bf_dinner\Entity\Date[]
     */
    public static function getAllFutureNodes () {
        $date = new \DateTime();
        $nodes = self::getEntityFieldQuery()
            ->fieldCondition('field_date', 'value', $date->format('Y-m-d'), '>')
            ->fieldOrderBy('field_date', 'value', 'ASC')
            ->execute();

        return self::convertArrayOfNodeObjectsToArrayOfDateObjects($nodes['node']);
    }

    /**
     * @param $series
     * @return \Drupal\bf_dinner\Entity\Date[]
     */
    public static function getAllNodesInSeries ($series) {
        $nodes = self::getEntityFieldQuery()
            ->fieldCondition(DINNER_FIELD_DATE_SERIES, 'value', $series)
            ->fieldOrderBy('field_date', 'value', 'ASC')
            ->execute();

        return self::convertArrayOfNodeObjectsToArrayOfDateObjects($nodes['node']);
	}
    

    /**
     * @param $nodes
     * @return \Drupal\bf_dinner\Entity\Date[]
     */
    public static function convertArrayOfNodeObjectsToArrayOfDateObjects ($nodes) {
        $out = [];
        foreach ($nodes as $node) {
            $out[] = self::makeDateObjectFromStdClass($node);
        }
        return $out;

	}

    /**
     * @param stdClass $node
     * @return \Drupal\bf_dinner\Entity\Date
     */
    public static function makeDateObjectFromStdClass ($node) {
        if (is_object($node)) {
            $node = $node->nid;
        }
        $node = node_load($node);

        $date = new \Drupal\bf_dinner\Entity\Date();
        foreach (get_object_vars($node) as $property => $value) {
            $date->$property = $value;
        }

        return $date;
	}

    /**
     * @param $user
     */
    public static function makeUserObjectFromStdClass ($us) {
        if (is_object($us)) {
            $us = $us->uid;
        }
        $us = user_load($us);
        $usObj = new \Drupal\bf_dinner\Entity\User();
        foreach (get_object_vars($us) as $property => $value) {
            $usObj->$property = $value;
        }
        return $usObj;
    }


	/**
	 * Return the maximum number in the field DINNER_FIELD_DATE_LIST.
	 */
	public static function getCurrentSeriesId () {
		$nodes = self::getEntityFieldQuery()
			->fieldOrderBy(DINNER_FIELD_DATE_SERIES, 'value', 'DESC')
			->execute();
		$node = array_shift($nodes['node']);
		return self::getDateFieldValue($node, DINNER_FIELD_DATE_SERIES, 0);
	}

    /**
     * @return array
     */
    public static function getAllSeriesForSelectOptions() {


        $table = 'field_data_' . DINNER_FIELD_DATE_SERIES;
        $column = DINNER_FIELD_DATE_SERIES . '_value';
        $res = db_select($table, 't')
            ->fields('t', [$column])
            ->execute()
            ->fetchAllAssoc(DINNER_FIELD_DATE_SERIES . '_value');

        $options = [];
        foreach ($res as $s) {
            $options[$s->$column] = $s->$column;
        }

        return $options;
	}

	/**
	 * Returns all unpublished future nodes.
	 *
	 * @return mixed
	 */
	public static function getFirstUnpublishedNode() {
		$nodes = self::getAllUnpublishedNodes();
		return array_shift($nodes);
	}

	/**
	 * Extract date from a dinner node.
	 *
	 * @param $node \stdClass|int
	 * @return \DateTime|bool
	 */
	public static function getNodeDate ($node) {
		if (is_object($node)) {
			$node = $node->nid;
		}

		$node = node_load($node);

		if ($items = field_get_items('node', $node, 'field_date')) {
			return new \DateTime($items[0]['value']);
		}

		return FALSE;
	}

	/**
	 * Get an EntiyFieldQuery prepared for retrieving dinner nodes.
	 *
	 * @return EntityFieldQuery
	 */
	public static function getEntityFieldQuery() {
		$nodeQuery = new EntityFieldQuery();
		return $nodeQuery
			->entityCondition('entity_type', 'node')
			->entityCondition('bundle', 'dinner')
			->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
	}

	/**
	 * Get a best-guess for the first date in the next dinner series to be created.
	 *
	 * @return DateTime
	 */
	public static function getNextSeriesFirstDateSuggestion() {
		return self::getLastPublishedDate()->add(
			new DateInterval('P1D')
		);
	}

	/**
	 * Get a best-guess for the last date in the next dinner series to be created.
	 *
	 * @return DateTime
	 */
	public static function getNextSeriesLastDateSuggestion() {
		$users = self::getUserCount();
		// add one day pr. user minus one
		return self::getNextSeriesFirstDateSuggestion()->add(
			new DateInterval('P' . ($users - 1) . 'D')
		);
	}

	/**
	 * Get number of users involved.
	 *
	 * @return int
	 */
	public static function getUserCount() {
		return sizeof(self::getAllUsers());
	}

	public static function getUserCountWhoSubmittedCurrentSeries () {
		$users = array();

		if ($from = self::getNodeDate(self::getFirstUnpublishedNode())) {
			$from = $from->format('Y-m-d');
		}

		return db_select('bf_dinner_user_date_status', 'mm')
			->fields('mm')
			->condition('date', $from, '>=')
			->execute()->rowCount();

	}

	public static function getUserCountWhoDidNotSubmitCurrentSeries () {
		return self::getUserCount() - self::getUserCountWhoSubmittedCurrentSeries();
	}

	/**
	 * Get a suggestion for the next step in dinner assignment process.
	 * Can be one of : create, edit, open, close, assign, review, publish.
	 *
	 * @return string
	 */
	public static function getNextStepSuggestion() {
		$nextStep = &drupal_static(__FUNCTION__);
		if (empty($nextStep)) {
			$nextStep = self::_getNextStepSuggestion();
		}
		return $nextStep;
	}


	/**
	 * Private helper for above method.
	 *
	 * @return string Representing which step is the next one suggested.
	 */
	private static function _getNextStepSuggestion() {
		if (sizeof(self::getAllUnpublishedNodes())) {
			return 'edit';
		}

		return 'create';

	}

	/**
	 * Get all involved users. Returned as array of stdClass objects.
	 *
	 * @return mixed
	 */
	public static function getAllUsers () {
		$temp = new EntityFieldQuery();
		$temp = $temp
			->entityCondition('entity_type', 'user')
			->fieldCondition(DINNER_FIELD_USER_LOAD_TOTAL, 'value', 0, '>')
			->fieldOrderBy(DINNER_FIELD_USER_HOUSE, 'tid', 'ASC')
			->execute();

        $users = [];
		foreach (array_keys($temp['user']) as $uid) {
		    $users[] = self::makeUserObjectFromStdClass($uid);
        }
		return $users;
	}

    /**
     * @param $u
     * @return array
     */
	public static function getOtherUsersInHouse ($u) {

		if (!is_object($u)) {
			$u = user_load($u);
		}
		$uid = $u->uid;

		if ($temp = field_get_items('user', $u, DINNER_FIELD_USER_HOUSE)) {
			$house = intval($temp[0]['tid']);
			// get all users attached to house, except the logged in user, which is already added to arrays
			$q = new EntityFieldQuery();
			$temp = $q
				->entityCondition('entity_type', 'user')
				->entityCondition('bundle', 'user')
				->propertyCondition('uid', $uid, '<>')
				->fieldCondition(DINNER_FIELD_USER_HOUSE, 'tid', $house)
				->execute();

			return $temp['user'];
		}

		return array();
	}

	/**
	 * @param $uid
	 */
	public static function getConflictRiscArray ($uid) {
		define('THRESHOLD', 10);

		$minAge = 100000;

		foreach (self::getOtherUsersInHouse($uid) as $u => $dummy) {
			if ($lastOpenDate = bf_dinner_utility::getUserFormLastOpenDate($u)) {
				$now = new \DateTime();
				$now->setTimestamp(time());
//				var_dump($now); var_dump($lastOpenDate);
				$age = $now->getTimestamp() - $lastOpenDate->getTimestamp();
				if ($age < THRESHOLD) {
					$account = user_load($u);

					return array(
						'risc' => TRUE,
						'messagePage' => self::getUserName($u) . ' har også sin kan-liste åben. For at undgå at I overskriver hinandens K´er, har I begge kun adgang til jeres egen kan-liste, og ikke til hele husstandens.',
						'messageAjax' => self::getUserName($u) . ' har lige åbnet sin kan-liste. For at undgå at I overskriver hinandens K´er, har I begge kun adgang til jeres egen kan-liste, og ikke til hele husstandens.',
						'type' => 'warning',
						'otherUserName' => self::getUserName($u),
						'imageTag' => theme('image_style', array('style_name' => 'small_thumb', 'path' => $account->picture->uri))

					//  Hvis du vil have adgang til hele husstanden igen, skal du bede ' . self::getUserName($u) . ' lukke kan-listen, dvs. f.eks. gå til forsiden af Blikintra.
					);
				}
				$minAge = min($minAge, $age);
			}
		}
		return array(
			'risc' => FALSE,
			'messageAjax' => $_GET['otherUserName'] . ' har lukket kan-listen. Du kan få adgang til alle husstandens kan-lister igen ved at gemme denne liste og åbne den igen.',
			'messagePage' => '',
			'type' => 'status',
			'minAge' => $minAge,

		);
	}

}

/**
 * Class bf_dinner_auto_assigner
 * Handles the process of auto-assigning users to dates.
 */
class bf_dinner_auto_assigner {

	/**
	 * Array of the users about to be assigned.
	 * @var
	 */
	protected $users;

	/**
	 * The subset of users who prefer half load.
	 * @var
	 */
	protected $usersWithHalfLoad;

    /**
     * @var
     */
    protected $usersWithSingleLoad;

	/**
	 * Array of dates about to be assigned.
	 *
	 * @var
	 */
	protected $dates;

	/**
	 * Array storing number of points for each user.
	 *
	 * @var
	 */
	protected $userPoints;

	/**
	 * Array storing number of points for each date.
	 * @var
	 */
	protected $datePoints;


	/**
	 * Contains result.
	 *
	 * @var
	 */
	protected $assigned;

    protected $interactive = FALSE;


	/**
	 * Array that holds information about dates being locked (can not be moved/swapped).
	 *
	 * @var array
	 */
	protected $locked = array();

	/**
	 * @var array
	 */
	protected $messages = array();

	/**
	 *
	 */
	public function initialize() {

	}

    /**
     * @param $interactive
     */
    public function setInteractive ($interactive) {
        $this->interactive = $interactive;
	}

	/**
	 *
	 * Load all users and count the sum of their points.
	 * Load all dates and count the sum of their points. Stop when users points sum is reached.
	 * Initialize places to put working data.
	 */
	public function loadInputData() {
		// load users
		$users = bf_dinner_utility::getAllUsers();
		$this->userPoints = 0;
		foreach ($users as $u) {
			// fetch points total, defaults to DINNER_LOAD_SINGLE
			$pointsTotal = DINNER_LOAD_SINGLE;
			if ($temp = field_get_items('user', $u, DINNER_FIELD_USER_LOAD_TOTAL)) {
				$pointsTotal = $temp[0]['value'];
			}
			// and points pr day, defaults to DINNER_LOAD_SINGLE
			$pointsPrDate = DINNER_LOAD_SINGLE;
			if ($temp = field_get_items('user', $u, DINNER_FIELD_USER_LOAD_PRDAY)) {
				$pointsPrDate = $temp[0]['value'];
			}
			$house = 0;
            if ($temp = field_get_items('user', $u, DINNER_FIELD_USER_HOUSE)) {
                $house = $temp[0]['tid'];
            }

			$this->users[$u->uid] = array(
				// user's name
				'name' => $u->uid . '<br/>' . bf_dinner_utility::getUserName($u),
                //
                'house' => $house,
				// array of dates holding status (possible / not possible) (are set just below)
				'status' => array(),
				// assigned points right now
				'points' => 0,
				// assigned points when we are finished
				'pointstotal' => $pointsTotal,
				// preferred points pr. date
				'pointsprdate' => $pointsPrDate,
			);

			$this->userPoints += $pointsTotal;

			// if user has half load, add to a second index, so we don't have to search for them later on
			if ($pointsPrDate == DINNER_LOAD_HALF) {
				$this->usersWithHalfLoad[$u->uid] = $this->users[$u->uid];
			}
            if ($pointsPrDate == DINNER_LOAD_SINGLE) {
                $this->usersWithSingleLoad[$u->uid] = $this->users[$u->uid];
            }

        }

		// load dates
		$nodes = bf_dinner_utility::getAllNodesBetweenDates(new DateTime('2018-03-27'), new DateTime('2018-05-15'));
		$this->datePoints = 0;
		foreach ($nodes as $node) {
			$node = node_load($node->nid);
			$date = field_get_items('node', $node, 'field_date')[0]['value'];
			$date = new \DateTime($date);
			$date_string = $date->format('Y-m-d');

			$dateLoad = bf_dinner_utility::getDateLoad($node->nid);
			if (! $dateLoad) {
				continue;
			}

            // Set assigned points to zero.
            $this->dates[$date_string]['date'] = $date->format('D Y-m-d');

            // Set assigned points to zero.
			$this->dates[$date_string]['points'] = 0;
			// Set target points for dinner (half/single/double).
			$this->dates[$date_string]['goal'] = $dateLoad;

			$this->assigned[$date_string] = array();

			// If there are users attached manually already, attach them, and mark them as locked.
			// @TODO For now, it is only possible to book an entire date in advance, not half a date (a single user).
			if (FALSE && $users = field_get_items('node', $node, DINNER_FIELD_USERS)) {
				foreach ($users as $i=>$u) {
					$uid = intval($u['target_id']);
					$this->assigned[$date_string][$i] = $uid;
					$this->users[$uid]['points'] = intval(DINNER_LOAD_SINGLE / sizeof($users));
				}
				// lock the assignments, so auto-assigner won't swap them
				$this->locked[$date_string] = TRUE;

				// add corresponding points to date
				$this->dates[$date_string]['points'] = DINNER_LOAD_SINGLE;
			} else {
				// There are no users attached. Load assigned users from temp storage. These are not locked.
				$uids = bf_dinner_utility::getAssignedUsers($date_string);
				foreach ($uids as $i => $uid) {
					$this->assigned[$date_string][$i] = $uid;
					$this->users[$uid]['points'] = intval(DINNER_LOAD_SINGLE / sizeof($users));
					// add corresponding points to date
					// @TODO : should we check here that the sum is correct ?
					$this->dates[$date_string]['points'] += bf_dinner_utility::getUserLoadPrDay($uid);
				}

			}



			$this->datePoints += DINNER_LOAD_SINGLE;
			if ($this->datePoints >= $this->userPoints) {
				break;
			}



		}

		foreach ($this->users as $uid=>$u) {

			foreach ($this->dates as $d => $userCount) {
				$this->users[$uid]['status'][$d] = bf_dinner_utility::getUserDateStatus($uid, $d, DINNER_USER_DATE_STATUS_POSSIBLE);
				$this->users[$uid]['statusReal'][$d] = bf_dinner_utility::getUserDateStatus($uid, $d, DINNER_USER_DATE_STATUS_UNKNOWN);
			}

		}

		$this->shuffleDates();
        $this->shuffleUsers();


        if (0) {
            print 'assigned at end of ' . __FUNCTION__; print_r($this->assigned);
            print 'dates at end of ' . __FUNCTION__; print_r($this->dates);

        }

//			print_r($users); print_r($this->users); print_r($this->dates);
	}

	/**
	 *
	 */
	public function makeRandomStatuses () {
		die;
		foreach ($this->users as $uid => &$us) {
			foreach ($this->dates as $date => $d) {
				$us['status'][$date] = rand(0, 100) < 15 ? 1 : 0;
			}
		}

	}

    /**
     * @return mixed
     */
    public function getAssigned() {
        return $this->assigned;
	}

    public function clearTemporaryForSeries($series) {
        if (empty($series)) {
            return;
        }

        db_update('bf_dinner_user_date_status')
//            ->condition('series', $series)
            ->fields(array(
                'assigned' => 0,
            ))
            ->execute();
	}

	/**
	 * @return int
	 */
	public function getDateCount () {
		return sizeof($this->dates);
	}

	/**
	 * @return int
	 */
	public function getUserCount () {
		return sizeof($this->users);
	}

	/**
	 * If users are not shuffled, and percentage of status 1 is high, it will result in users with low user-id always assigned to early dates
	 * and high user-id to late dates.
	 * This will shuffle users so they appear in random order before start.
	 */
	public function shuffleUsers () {

	}

    public function orderUsers () {

	}

	/**
	 * If dates are not shuffled, it will result in users that chose half dinner load, will have the two half dinner loads on adjacent dates,
	 * or very close together. The higher the percentage of status 1, the closer they will be.
	 * This will shuffle dates so they appear in random order before start.
	 */
	public function shuffleDates () {
        uasort($this->dates, function ($a, $b) {
            return rand(-1, 1);
        });
	}

    /**
     *
     */
    public function orderDates () {
        ksort($this->dates);
    }

	/**
	 *
	 */
	public function validateInput() {
		$this->uk = array();
		$this->dk = array();
		$this->ukHistogram = array();
		$this->dkHistogram = array();

		$this->totalDatePoints = 0;
		$this->totalUserPoints = 0;


		foreach ($this->dates as $date => $userCount) {
			$this->dk[$date] = 0;
			$this->totalDatePoints += DINNER_LOAD_SINGLE;
		}

		$prefOtherCount = 0;
		foreach ($this->users as $uid => $us) {
			$this->totalUserPoints += $us['pointstotal'];
//			$this->uk[$uid] = 0;
			foreach ($us['status'] as $d => $i) {
				if (DINNER_USER_DATE_STATUS_POSSIBLE == $i) {
					$this->uk[$uid]++;
					$this->dk[$d]++;
				}
			}

			if ($us['pointsprdate'] == DINNER_LOAD_HALF) {
				$prefOtherCount++;
				$prefOtherUid = $uid;
			}
		}
//		print_r($this->uk);print_r($this->dk);

		foreach ($this->uk as $uid => $i) {
			$this->ukHistogram[$i] ++;
			if ($i == 0) {
				drupal_set_message("won't work for user $uid\n");
				return FALSE;
			}

		}
		foreach ($this->dk as $date => $i) {
			$this->dkHistogram[$i] ++;
			if ($i == 0) {
				drupal_set_message("won't work for date $date \n");
				return FALSE;
			}
		}

		if ($this->totalUserPoints != $this->totalDatePoints) {
			drupal_set_message("there is mismatch in points (users:$this->totalUserPoints vs. dates:$this->totalDatePoints)");
			return FALSE;
		}

		if ($prefOtherCount == 1) {
            $this->users[$prefOtherUid]['pointsprdate'] = DINNER_LOAD_SINGLE;
            $this->usersWithHalfLoad = [];
            $this->usersWithSingleLoad[$prefOtherUid] = $this->users[$prefOtherUid];
			drupal_set_message("Only user $prefOtherUid has half load. It has been set to full");
			return FALSE;
		}

		return TRUE;
	}

	/**
	 *
	 * Preconditions :
	 * - no assigned users
	 */
	public function assignHalfLoads () {
		$users = $this->usersWithHalfLoad;
        if (! sizeof($users)) {
            return;
        }
        if (TRUE) {
            /**
             * Joins users in same house, so they are kept together when we generate permutations in a second
             */
            $temp = [];
            foreach ($users as $uid => $us) {
                if (empty($temp[$uid])) {
                    $us = user_load($uid);
                    $j[$uid] = [$uid];
                    if (TRUE) {
                        if ($temp = field_get_items('user', $us, DINNER_FIELD_USER_HOUSE)) {
                            $house = intval($temp[0]['tid']);
                            $otherUsers = bf_dinner_utility::getOtherUsersInHouse($uid);
                            foreach ($otherUsers as $otherUser) {
                                $j[$uid][] = $otherUser->uid;
                                $temp[$otherUser->uid] = 1;
                            }
                        }
                    }
                }

            }
            $uids = [];
            foreach ($j as $uid => $a) {
                $uids[] = implode(',', $a);
            }
        } else {
		    $uids = array_keys($users);

        }

		shuffle($uids);


		$permutations = array();
		$this->generatePermutations($uids, array(), $permutations);

        // Now that permutations are generated, separate users again.
        $temp = $permutations;
        $permutations = [];
        foreach ($temp as $count => $uids) {
            foreach ($uids as $u) {
                foreach (explode(',', $u) as $uu) {
                    $permutations[$count][] = $uu;
                }
            }
        }

        $this->messages[] = sprintf('Placing half load users attempting %d permutations', sizeof($permutations));

        /**
         * At this point $permutations is an array of x! elements, where x is the number of users wishing half load pr. day
         */
        foreach ($permutations as $count => $uids) {
			$u2 = $uids[sizeof($uids) - 1];

            $this->assigned = array();
            $dates = $this->dates;

			$a = 0;
			foreach ($uids as $u1) {
				foreach ($dates as $date => $dummy) {
					if (
					    ! empty($this->users[$u1]['status'][$date])
                        && ! empty($this->users[$u2]['status'][$date])
						&& empty($this->assigned[$date])
					) {

					    $valid = TRUE;
					    foreach (array($u1, $u2) as $uid) {

                            foreach ($this->assigned as $d => $assigned) {
                                if (is_array($assigned) && in_array($uid, $assigned)) {
                                    echo "uid: $uid - date: $date - other assigned date: $d. ";
                                    if ($this->getDaysDifference($date, $d) < $this->getMinimumIntervalDays()) {
                                        $valid = FALSE;
                                    }
                                }
                            }

                        }

                        if ($valid) {
                            $this->assigned[$date] = array($u1, $u2);
                            $this->locked[$date] = TRUE;
                            $dates[$date]['points'] += DINNER_LOAD_SINGLE;
                            $users[$u1]['points'] += DINNER_LOAD_HALF;
                            $users[$u2]['points'] += DINNER_LOAD_HALF;

                            $a ++;
    						break;
                        }
					}

				}

				$u2 = $u1;
			}

			if ($a >= sizeof($users)) {
			    $this->messages[] = sprintf('All half load users placed after %d permutations', $count);
				break;
			}
		}

//		echo "permutation number $count \n";

		foreach ($users as $uid => $us) {
			$this->users[$uid]['points'] = $us['points'];
		}

		$this->dates = $dates;

        print 'assigned at end of ' . __FUNCTION__;
        print_r($this->assigned);
        print 'dates at end of ' . __FUNCTION__;
        print_r($this->dates);

    }

	/**
	 * 1. Check if there is a user with not enough points, a date with not enough points, and that user can be assigned that date. If there is, asssign.
	 * 2. If not : find an unassigned date, then find a random date, and check if one user can be moved from one to the other.
	 * 3. Repeat step 1 and 2 a thousand times or until all dates have enough points.
	 *
	 */
	public function assignSingleLoads () {
		$allDone = FALSE;
		$count = 0;
		$swaps = 0;

		while (!$allDone && $count <= 1000) {
			$changed = FALSE;
			// loop through all dates and all users and look for holes
			foreach ($this->dates as $date => $p) {
				// if this date has sufficient points, skip
				if ($this->dates[$date]['points'] >= $this->dates[$date]['goal']) {
					continue;
				}

                foreach ($this->users as $uid => $us) {

					$points = $us['pointsprdate'];

					// if this user's points would make the date's points exceed, skip
					if ($this->dates[$date]['points'] + $points > $this->dates[$date]['goal']) {
						continue;
					}

					// if user has sufficient points, skip
					if ($this->users[$uid]['points'] >= $this->users[$uid]['pointstotal']) {
						continue;
					}


					if ($this->users[$uid]['points'] > 0) {
                        foreach ($this->assigned as $d => $assigned) {
                            if (is_array($assigned) && in_array($uid, $assigned)) {
                                echo "<p>uid: $uid - date: $date - other assigned date: $d.</p>";
                                if ($this->getDaysDifference($date, $d) < $this->getMinimumIntervalDays()) {
                                    continue 2;
                                }
                            }
					    }
                    }

					// if user is already assigned to this date, skip
					if (in_array($uid, $this->assigned[$date])) {
						continue;
					}

					// if it is not possible for user to be assigned this date, skip
					if (! $us['status'][$date]) {
						continue;
					}

					// assign user
					$changed = TRUE;
					$this->assigned[$date][] = $uid;
					$this->users[$uid]['points'] += $points;
					$this->dates[$date]['points'] += $points;
					//


				}

			}
			/*
						echo "assigned:";
						print_r($this->assigned);
			*/

			if (!$changed) {

				/*
				$unassignedDates = array();
				$unassignedUsers = array();
				foreach ($this->assigned as $date => $i) {
					if (!$i) {
						$unassignedDates[] = $date;
					}
				}
				foreach ($this->users as $uid => $user) {
					if (!in_array($uid, $this->assigned)) {
						$unassignedUsers[] = $uid;
					}

				}

				//echo "unassigned dates : " . implode(',', $unassignedDates). ' unassigned users :' . implode(',', $unassignedUsers) . "\n";

				*/
				// no holes found - swap an empty with a random
				foreach ($this->dates as $date => $i) {
					if (! empty($this->locked[$date])) {
						continue;
					}
					if ($i['points'] < $i['goal']) {
						$missingPoints = $i['goal'] - $i['points'];
						$d1 = $date;

						// pick a random date
						$randomDate = array_keys($this->assigned)[rand(0, sizeof($this->assigned) - 1)];

						// if we've picked the same date, no point in swapping, so skip
						if ($d1 == $randomDate) {
							continue;
						}

						// if there are no assignees on the random date, skip
						if (! sizeof($this->assigned[$randomDate])) {
							continue;
						}
						// if the random date is locked, skip
						if (! empty($this->locked[$randomDate])) {
							continue;
						}


						// choose strategy : swap a single user or swap entire date
						if (TRUE) {

							// swap entire date

                            $points = $this->dates[$d1]['goal'];

                            // if random date has a different total load than the date in question, this strategy won't work - so skip
                            if ($this->dates[$d1]['goal'] != $this->dates[$randomDate]['goal']) {
                                continue;
                            }

                            $canSwap = TRUE;

							// if a user assigned to the random date can not be swapped, skip entire swap
							foreach ($this->assigned[$randomDate] as $uid) {
								$canSwap &= ! empty($this->users[$uid]['status'][$d1]);

                                // find this users other assigned date, and check distance
                                foreach ($this->assigned[$d1] as $d => $assigned) {
                                    if (is_array($assigned) && in_array($uid, $assigned)) {
                                        echo "<p>uid: $uid - date: $date - other assigned date: $d.</p>";
                                        if ($this->getDaysDifference($date, $d) < $this->getMinimumIntervalDays()) {
                                            $canSwap = FALSE;
                                        }
                                    }
                               }

                            }

                            if (! $canSwap) {
							    continue;
                            }

							// move user $u2 from $d2 to $d1, and move the corresponding points
							echo "<p>move all users (" . implode(',', $this->assigned[$randomDate]) . ") from $randomDate to $d1, and move the corresponding $points points ({$this->dates[$randomDate]['points']} , {$this->dates[$d1]['points']})";
							// assign user(s) to date d1
							$this->assigned[$d1] = $this->assigned[$randomDate];
                            // unassign user(s) from randomDate
                            $this->assigned[$randomDate] = array();
                            // add points
							$this->dates[$d1]['points'] += $points;
                            // subtract points
							$this->dates[$randomDate]['points'] -= $points;

							echo "-> ({$this->dates[$randomDate]['points']} , {$this->dates[$d1]['points']})</p>";

						} else {

							// find first assigned user
							$u2 = $this->assigned[$randomDate][0];

							// if this user is already assigned, skip
							if (in_array($u2, $this->assigned[$d1])) {
								continue;
							}

							// if the user assigned the random date can not be swapped, skip
							if (empty($this->users[$u2]['status'][$d1])) {
								continue;
							}

							$points = $this->users[$this->assigned[$randomDate][0]]['pointsprdate'];

							if ($points != $missingPoints) {
								continue;
							}

							 // move user $u2 from $d2 to $d1, and move the corresponding points
							echo "<p>move user $u2 from $randomDate to $d1, and move the corresponding $points points ({$this->dates[$randomDate]['points']} , {$this->dates[$d1]['points']})";
							// add user u2 to date d1
							$this->assigned[$d1][] = $u2;
							$this->dates[$d1]['points'] += $points;
							// remove user u2 from date d2
							foreach ($this->assigned[$randomDate] as $i => $uid) {
								if ($uid == $u2) {
									$this->assigned[$randomDate] = array_merge(
										array_slice($this->assigned[$randomDate], 0, $i),
										array_slice($this->assigned[$randomDate], $i + 1)
									);
									break;
								}
							}
							$this->dates[$randomDate]['points'] -= $points;
							echo "-> ({$this->dates[$randomDate]['points']} , {$this->dates[$d1]['points']})</p>";
						}

						// increase swap counter
						$swaps++;
					}
				}

			}

			$count ++;

		}

		$allDone = TRUE;
		// all done means all dates have two points
		foreach ($this->dates as $date => $p) {
			$allDone &= (bool)($p['points'] == $p['goal']);
		}


		if ($allDone) {
			$this->messages[] = "Success efter $swaps ombytninger";
		} else {
			$this->messages[] = "Fejl. Giver op efter $count runder.";
		}


	}

	/**
	 * Makes an array of all permutations of array. Is used for assigning users who chose half load.
	 *
	 * Thanks to http://stackoverflow.com/questions/5506888/permutations-all-possible-sets-of-numbers
	 *
	 * @param $items
	 * @param array $perms
	 * @param $result
	 */
	protected function generatePermutations($items, $perms = array(), &$result) {
		if (empty($items)) {
			$result[] = $perms;
		} else {
			for ($i = count($items) - 1; $i >= 0; --$i) {
				$newitems = $items;
				$newperms = $perms;
				list($foo) = array_splice($newitems, $i, 1);
				array_unshift($newperms, $foo);
				$this->generatePermutations($newitems, $newperms, $result);
			}
		}

	}

    /**
     * @param $d1 string
     * @param $d2 string
     */
    public function getDaysDifference ($d1, $d2) {
        $u1 = strtotime($d1);
        $u2 = strtotime($d2);
        return intval((abs($u1 - $u2) / 86400));
    }


    /**
     * The minimum interval between two assignments of a single user. In days.
     * 0 : same day (not possible for other reasons)
     * 1 : like monday and tuesday
     * 2 : like monday and wednesday
     *
     * @return int
     */
    public function getMinimumIntervalDays () {
        return 3;
    }

	/**
	 *
     * Write contents of $this->assigned to DB - temporary part.
     *
	 */
	public function writeToTemporary () {
		foreach ($this->assigned as $date => $uids) {
			bf_dinner_utility::setDateAssignedUsers($uids, $date);
		}
	}


    /**
     * @return array
     */
	public function getMessages () {
		return $this->messages;
	}

	/**
	 * Make html for a table that shows the current status of the assigner object.
	 *
	 * @return string
	 */
	public function getAssignmentHtml () {
        drupal_add_js('misc/tableheader.js');

	    $this->orderDates();

		// build json for js widget
		foreach ($this->users as $uid => $u) {
			$json['users'][$uid] = array(
				'pointstotal' => $u['pointstotal'],
				'pointsprdate' => $u['pointsprdate'],

			);
		}
		foreach ($this->dates as $date => $d) {
			$json['dates'][$date] = array(
				'pointstotal' => $d['goal'],
			);
		}
		$out = '<script>var config = ' . json_encode($json, JSON_PRETTY_PRINT) . ';</script>';

		$out .= '<link rel="stylesheet" href="/sites/all/modules/bf_dinner/css/bf_dinner.css"></link>';
		$out .= '<script src="/sites/all/modules/bf_dinner/js/admin.js"></script>';
		$out .= '<ul>';
		$out .= sprintf('<li>%s : %d</li>', 'Users' , $this->getUserCount()) ;
		$out .= sprintf('<li>%s : %d</li>', 'Dates' , $this->getDateCount()) ;
		$out .= sprintf('<li>%s : %d</li>', 'User points' , $this->totalUserPoints) ;
		$out .= sprintf('<li>%s : %d</li>', 'Date points' , $this->totalDatePoints) ;
		$out .= '</ul>';

		$out .= "<table class='assigned-table scroll sticky-enabled" . ($this->interactive ? ' interactive' : '') . "'>
		<thead>
		<tr><th>user</th><th></th><th></th>";

		foreach ($this->users as $uid => $i) {
			$out .= '<th class="user user-' . $uid . '" data-uid="' . $uid . '">' . str_pad($i['name'], 3, ' ', STR_PAD_LEFT) . "</th>";
		}


		$out .= '<td>Points</td>';
		$out .= "<tr><th>total</th><th></th><th></th>";
		foreach ($this->users as $uid => $i) {
			$out .= '<th class="user user-' . $uid . '" data-uid="' . $uid . '">' . str_pad($i['pointstotal'], 3, ' ', STR_PAD_LEFT) . ' / ' . str_pad($i['pointsprdate'], 3, ' ', STR_PAD_LEFT) . "</th>";
		}

		$out .= '<td></td>';
        $out .= '</thead>';
        $out .= '</tbody>';

		foreach ($this->dates as $date => $p) {

			$out .= "<tr>";
			$out .= "<th class='date date-$date' data-date='$date'>" . $p['date'];

			$out .= "<th class='date date-$date' data-date='$date'>" . $p['goal'];
            $out .= "<th class='date date-$date' data-date='$date'>" . $p['points'];
			$_house = 0;
            foreach ($this->users as $uid => $i) {
			    $isAssigned = in_array($uid, $this->assigned[$date]);
				$isLocked = $this->locked[$date];

				$class = 'status';
				$class .= ' user-' . $uid;
				$class .= ' date-' . $date;

				$class .=  ' ' . (DINNER_USER_DATE_STATUS_UNKNOWN == $i['statusReal'][$date] ? 'status-unknown' : ($i['statusReal'][$date] ? 'status-possible' : 'status-not-possible'));
				$class .=  ' ' . ($isAssigned ? 'assigned-1' : 'assigned-0');
				switch ($i['pointstotal']) {
					case DINNER_LOAD_DOUBLE :
						$class .= ' user-pointstotal-double';
						break;
				}

                $class .= ' house-' . $i['house'];
                if ($i['house'] != $_house) {
                    $class .= ' first-user-in-house';
                    $_house = $i['house'];
                }

                $text = $isAssigned ? ($isLocked ? 'L' : 'X') : '';

				$out .= "<td class='$class' data-uid='$uid' data-date='$date'><div>" . $text . "</div></td>";

			}

			$out .= '<td>' . $this->dk[$date] . '</td>';

			$out .= "</tr>";
		}

		$out .= '<tr>';
		$out .= '<th>Total</th>';
		$out .= '<th>' . /* total */ '</th>';
		$out .= '<th>' . /* total */ '</th>';
		foreach ($this->users as $uid => $i) {
			$out .= '<td>' . $this->uk[$uid] . '</td>';
		}

		$totalKs = array_sum($this->uk);
		$out .= '<td>' . sprintf('%d (%d %%)', $totalKs, ($totalKs *100 / ($this->getUserCount() * $this->getDateCount()))) . '</td>';
		$out .= '</tr>';

		$out .= '</tbody></table>';

		$out .= '<div class="legend"><div class="legend-bar status status-unknown">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div> Ikke udfyldt </div>';
		$out .= '<div class="legend"><div class="legend-bar status status-not-possible">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div> Kan ikke lave mad </div>';
		$out .= '<div class="legend"><div class="legend-bar status status-possible">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div> Kan lave mad </div>';
		$out .= '<div class="legend"><div class="legend-bar">X</div>Tildelt automatisk </div>';
		$out .= '<div class="legend"><div class="legend-bar">L</div>Tildelt manuelt</div>';

		return $out;
	}
}

